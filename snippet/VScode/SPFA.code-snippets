{
    "SPFA": {
    "prefix": "SPFA",
    "body": [
        "template <class T>",
        "struct Graph {",
        "    /*",
        "    SPFA 求最短路",
        "    g.addEdge(u, v, w); // 无向边",
        "    g.addArc(u, v, w); // 有向边",
        "",
        "    std::vector<int> par;",
        "    g.SPFA(s, &par); // 求最短路, 并记录路径",
        "    */",
        "    int n;",
        "    std::vector<std::vector<std::pair<int, T>>> adj;",
        "    std::vector<T> dist;",
        "",
        "    const T INF = std::numeric_limits<T>::max() / 4;",
        "",
        "    Graph(int n) {",
        "        this->n = n;",
        "        adj.assign(n + 1, {});",
        "        dist.assign(n + 1, INF);",
        "    }",
        "",
        "    void addEdge(int u, int v, T w) {",
        "        adj[u].emplace_back(v, w), adj[v].emplace_back(u, w);",
        "    }",
        "",
        "    void addArc(int u, int v, T w) {",
        "        adj[u].emplace_back(v, w);",
        "    }",
        "",
        "    bool SPFA(int s, std::vector<int> *par = nullptr) {",
        "",
        "        std::vector<int> inq(n + 1);",
        "        std::vector<int> cnt(n + 1); // 入队次数",
        "        if (par) {",
        "            par->assign(n + 1, -1);",
        "        }",
        "",
        "        std::deque<int> q;",
        "        q.push_back(s);",
        "        inq[s] = 1, dist[s] = 0;",
        "",
        "        while (!q.empty()) {",
        "            int u = q.front();",
        "            q.pop_front();",
        "            inq[u] = 0;",
        "",
        "            T du = dist[u];",
        "            if (du == INF) {",
        "                continue;",
        "            }",
        "",
        "            for (auto [v, w] : adj[u]) {",
        "                if (du + w < dist[v]) {",
        "                    dist[v] = du + w;",
        "                    if (par) {",
        "                        (*par)[v] = u;",
        "                    }",
        "",
        "                    if (!inq[v]) {",
        "                        if (!q.empty() && dist[v] < dist[q.front()]) {",
        "                            q.push_front(v);",
        "                        } else {",
        "                            q.push_back(v);",
        "                        }",
        "",
        "                        inq[v] = 1;",
        "",
        "                        if (++cnt[v] == n) {",
        "                            return 0; // 存在负环",
        "                        }",
        "                    }",
        "                }",
        "            }",
        "        }",
        "        for (int i = 1; i <= n; ++i) {",
        "            dist[i] = (dist[i] == INF ? (T)-1 : dist[i]);",
        "        }",
        "        return 1;",
        "    }",
        "",
        "    static std::vector<int> get_path(int s, int t, std::vector<int> &par) {",
        "        std::vector<int> path;",
        "        for (int v = t; v != -1; v = par[v]) {",
        "            path.push_back(v);",
        "        }",
        "        std::reverse(path.begin(), path.end());",
        "",
        "        return path;",
        "    }",
        "};"
    ],
    "description": "SPFA"
    }
}