{
    "BinaryTrie": {
    "prefix": "BinaryTrie",
    "body": [
        "struct BinaryTrie {",
        "    /* ",
        "    01-Trie（按位存 int）",
        "    BinaryTrie bt;",
        "    bt.insert(x, times=1);     // 插入",
        "    bt.erase(x,  times=1);     // 删除",
        "    bt.count(x);               // x 的出现次数",
        "    bt.max_xor(x);             // 返回与 x 的最大异或值 (x XOR best)",
        "    */",
        "",
        "    static constexpr int A = 2;      // 只有 0/1 两个分支",
        "    static constexpr int W = 31;     // 最高位下标（int 32 位：31..0）",
        "",
        "    struct Node {",
        "        int ch[A];",
        "        int pass;   // 经过该节点的数的个数",
        "        int end;    // 在该节点结束的数的个数",
        "        Node() { ",
        "            pass = end = 0; ",
        "            ch[0] = ch[1] = -1; ",
        "        }",
        "    };",
        "",
        "    std::vector<Node> t;",
        "    int sz = 0; // 集合中数的总个数",
        "",
        "    BinaryTrie() {",
        "        t.push_back(Node());",
        "    }",
        "    void clear() { ",
        "        t.clear(); ",
        "        t.push_back(Node()); ",
        "        sz = 0;",
        "    }",
        "",
        "    void insert(int x, int times = 1) {",
        "        // 插入 x",
        "        uint32_t v = (uint32_t)x;",
        "        int u = 0;",
        "        for (int b = W; b >= 0; --b) {",
        "            int bit = (v >> b) & 1u;",
        "            if (t[u].ch[bit] == -1) {",
        "                t[u].ch[bit] = (int)t.size();",
        "                t.push_back(Node());",
        "            }",
        "            u = t[u].ch[bit];",
        "            t[u].pass += times;",
        "        }",
        "        t[u].end += times;",
        "        sz += times;",
        "    }",
        "",
        "    int count(int x) {",
        "        // x 的出现次数",
        "        uint32_t v = (uint32_t)x;",
        "        int u = 0;",
        "        for (int b = W; b >= 0; --b) {",
        "            int bit = (v >> b) & 1u;",
        "            int nx = t[u].ch[bit];",
        "            if (nx == -1) {",
        "                return 0;",
        "            }",
        "            u = nx;",
        "        }",
        "        return t[u].end;",
        "    }",
        "",
        "    bool erase(int x, int times = 1) {",
        "        // 删除 x",
        "        if (times <= 0) {",
        "            return 1;",
        "        }",
        "        if (count(x) < times) {",
        "            return 0;",
        "        }",
        "",
        "        uint32_t v = (uint32_t)x;",
        "        int u = 0;",
        "        for (int b = W; b >= 0; --b) {",
        "            int bit = (v >> b) & 1u;",
        "            u = t[u].ch[bit];",
        "            t[u].pass -= times;",
        "        }",
        "        t[u].end -= times;",
        "        sz -= times;",
        "",
        "        return 1;",
        "    }",
        "",
        "    ",
        "    int max_xor(int x) {",
        "        // 与 x 的最大异或值",
        "        if (sz == 0) {",
        "            return 0;",
        "        }",
        "        uint32_t v = (uint32_t)x, ans = 0;",
        "        int u = 0;",
        "        for (int b = W; b >= 0; --b) {",
        "            int bit = (v >> b) & 1u;",
        "            int want = bit ^ 1;",
        "            int nx = t[u].ch[want];",
        "            if (nx != -1 && t[nx].pass > 0) {",
        "                ans |= (1u << b);",
        "                u = nx;",
        "            } else {",
        "                u = t[u].ch[bit];",
        "            }",
        "        }",
        "        return (int)ans;",
        "    }",
        "",
        "    int min_xor(int x) const {",
        "        if (sz == 0) {",
        "            return 0;",
        "        }",
        "        uint32_t v = (uint32_t)x, ans = 0;",
        "        int u = 0;",
        "        for (int b = W; b >= 0; --b) {",
        "            int bit = (v >> b) & 1u;",
        "            int same  = t[u].ch[bit];",
        "            int other = t[u].ch[bit ^ 1];",
        "            if (same != -1 && t[same].pass > 0) {",
        "                u = same;",
        "            } else {",
        "                u = other;",
        "                ans |= (1u << b);",
        "            }",
        "        }",
        "        return (int)ans;",
        "    }",
        "};"
    ],
    "description": "BinaryTrie"
    }
}